description "{{cname}} container"
author "tools@digital.justice.gov.uk"

# If linking is set up on this container then depend the service start/stop
# on the link target container services. If theres no linking, then default
# to starting when docker starts
{% if (cdata.get('links', [])|length) > 0 %}
start on ({% for link_config in cdata.get('links', []) if link_config.get('required', True) %}{% if loop.index > 1 %} or{% endif %} started {{ link_config.get('link') }}_container{% endfor %})
stop on runlevel [!2345] or ({% for link_config in cdata.get('links', []) if link_config.get('required', True) %}{% if loop.index > 1 %} or{% endif %} stopped {{ link_config.get('link') }}_container{% endfor %})
{% else %}
start on filesystem and started docker
stop on runlevel [!2345]
{% endif %}

respawn
respawn limit 5 300
env HOME=/root
script
        PILLAR_TAG='{{ tag | replace("'", "'\\''") }}'
        if [ -z $TAG ]; then
            TAG=$PILLAR_TAG
        fi

        {%  if 'volumes' in cdata %}
        VOL_OPTS="{% for descr, vol_set in cdata['volumes'].items() %} -v {{vol_set['host']}}:{{vol_set['container']}} {% endfor %}"
        {% endif %}

        {% if 'ports' in cdata %}
        PORT_OPTS="{% for descr, port_set in cdata['ports'].items() %} -p {{port_set['host']}}:{{port_set['container']}} {% endfor %}"
        {% endif %}

        if [ -f /etc/docker_env.d/{{cname}} ]; then
                ENV_OPTS="--env-file /etc/docker_env.d/{{cname}}"
        fi

		# If clustering is enabled for this container, and we have neighbour hosts details are available
		# then add the neighbour and container alias <container_name>.<remote_instance_dns_name> to
		# the hosts file in the container
		{% set ec2_neighbours = salt['grains.get']('ec2_neighbours', {}) %}
		{% set ec2_local_private_dns_name = salt['grains.get']('ec2_local:private_dns_name', '') %}
		{% set ec2_local_private_dns_name_safe = salt['grains.get']('ec2_local:private_dns_name_safe', '') %}

		{% if 'enable_clustering' in cdata and cdata['enable_clustering'] == True %}
		HOSTS_OPTS="{% for ip, neighbours in ec2_neighbours.items() %} --add-host={{neighbours['private_dns_name']}}:{{ip}} --add-host={{cname}}.{{neighbours['private_dns_name']}}:{{ip}}{% endfor %}"
		HOSTS_OPTS_SAFE="{% for ip, neighbours in ec2_neighbours.items() %} --add-host={{neighbours['private_dns_name_safe']}}:{{ip}} --add-host={{cname}}-{{neighbours['private_dns_name_safe']}}:{{ip}}{% endfor %}"
		CLUSTER_NODES="[ {% for ip, neighbours in ec2_neighbours.items() %} '{{cname}}.{{neighbours['private_dns_name']}}'{% if not loop.last %},{% endif %} {% endfor %}]"
		CLUSTER_NODES_SAFE="[{% for ip, neighbours in ec2_neighbours.items() %} '{{cname}}-{{neighbours['private_dns_name_safe']}}'{% if not loop.last %},{% endif %} {% endfor %}]"
		HOSTNAME_OPTS=" -h {{cname}}-{{ec2_local_private_dns_name_safe}} "
		{% endif %}

		{% if 'links' in cdata %}
		LINK_CONTAINERS="{% for link_config in cdata.get('links') %} --link {{ link_config.get('link') }}:{{ link_config.get('link') }} {% endfor %} "
		{% endif %}

    docker run --name="{{ cname }}" {{cdata.get('docker_args', '')}} \
    	${LINK_CONTAINERS} \
    	-e "CLUSTER_NODES=${CLUSTER_NODES}" \
    	-e "CLUSTER_NODES_SAFE=${CLUSTER_NODES_SAFE}" \
    	${HOSTNAME_OPTS} ${HOSTS_OPTS} ${HOSTS_OPTS_SAFE} ${ENV_OPTS} ${VOL_OPTS} ${PORT_OPTS} {{container_full_name}}:"$TAG" {{cdata.get('startup_args', '')}}

end script

# Pre start check makes sure that we retry a few times to allow any linked containers to
# come up before starting, so that we can link to them successfully
pre-start script
				{% if 'links' in cdata %}
				max_retry=10
        echo INFO: Checking if containers required for linking are running...
{% for link_config in cdata.get('links') %}
				for i in $(seq 1 ${max_retry})
        do
          found_container=$(docker inspect --format='{% raw %}{{.Name}}{% endraw %}' {{ link_config.get('link') }} 2>/dev/null)
          if [ "${found_container}" = "/{{ link_config.get('link') }}" ]; then
          	echo INFO: Found container required for linking ${found_container}...
          	break
          elif [ "${i}" = "${max_retry}" ]; then
          	echo CRITICAL: Retry timed out on container required for linking, {{ link_config.get('link') }}, exiting...
          	exit 1
          else
          	echo WARNING: Could not find container required for linking, {{ link_config.get('link') }}, retry ${i}/${max_retry}...
          	sleep 3
          fi
        done
{% endfor %}
{% endif%}

end script

# Post start script checks that the container it actually running
# It uses a small number of retries since the startup of containers
# is not instantaneous
post-start script
    echo INFO: Checking if container {{cname}} is running
	# Test for success
	max_retry=10
	for i in $(seq 1 ${max_retry})
	do
		RUNNING_ID="`docker ps -q --filter name={{cname}}`"
		if [ -z ${RUNNING_ID} ]; then
			echo WARNING: Docker not started yet, retrying...
			sleep 3
		else
			echo INFO: Docker instance has started successfully with id ${RUNNING_ID}
			exit 0
		fi
	done
	echo ERROR: Docker failed to start instance
	exit 1
end script

post-stop exec docker rm -f {{ cname }}
